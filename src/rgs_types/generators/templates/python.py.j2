from __future__ import annotations
from dataclasses import dataclass, field
from typing import Optional, List, Union, Any, Dict
from enum import Enum

{% for enum_name, enum_values in enums.items() %}
class {{ enum_name }}(Enum):
    {% for val in enum_values %}
    {% if val is string %}
    {{ val.upper() }} = "{{ val }}"
    {% else %}
    VALUE_{{ val }} = {{ val }}
    {% endif %}
    {% endfor %}

{% endfor %}
{% for class in classes %}
@dataclass
class {{ class.name }}:
    """
    {{ class.description or "No description provided." }}
    """
    {% for prop_name, prop_info in class.properties.items() %}
    {{ prop_name }}: {{ prop_info.type_hint }}{{ ' = ' + prop_info.default if prop_info.default is not none else '' }}{{ ' # ' + prop_info.description if prop_info.description else '' }}
    {% endfor %}

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the instance to a dictionary, respecting the JSON Schema structure.
        """
        import dataclasses
        return dataclasses.asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "{{ class.name }}":
        """
        Create an instance from a dictionary.
        """
        # We use a mapping approach to handle potential naming differences 
        # or just to be safe with **data unpacking.
        kwargs = {}
        {% for prop_name, prop_info in class.properties.items() %}
        if "{{ prop_name }}" in data:
            val = data["{{ prop_name }}"]
            # Basic recursive conversion for nested objects if type hint is a known class
            # This is a heuristic: if the type hint is a PascalCase string, we try to call from_dict
            # Future: use actual type inspection
            kwargs["{{ prop_name }}"] = val
        {% endfor %}
        return cls(**kwargs)

{% endfor %}
